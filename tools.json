{
  "filter_even_numbers": "def filter_even_numbers(numbers: list[int]) -> list[int]:\n    \"\"\"\n    Filter even numbers from a list of integers.\n\n    Args:\n        numbers (list[int]): A list of integers to filter.\n\n    Returns:\n        list[int]: A list containing only the even integers from the input list.\n\n    Raises:\n        ValueError: If the input is not a list of integers.\n\n    Example:\n        >>> filter_even_numbers([1, 2, 3, 4, 5, 6])\n        [2, 4, 6]\n    \"\"\"\n    if not isinstance(numbers, list):\n        raise ValueError(\"Input must be a list of integers.\")\n    if not all(isinstance(num, int) for num in numbers):\n        raise ValueError(\"All elements in the list must be integers.\")\n\n    even_numbers = [num for num in numbers if num % 2 == 0]\n    return even_numbers\n",
  "read_file_lines": "def read_file_lines(file_path: str) -> list[str]:\n    \"\"\"\n    Read all lines from a file and return them as a list of strings.\n\n    Args:\n        file_path (str): The path to the file to be read.\n\n    Returns:\n        list[str]: A list containing each line of the file as a string.\n\n    Raises:\n        FileNotFoundError: If the file does not exist at the specified path.\n        PermissionError: If there is no permission to read the file.\n        ValueError: If the file path is not a string.\n\n    Example:\n        >>> read_file_lines('example.txt')\n        ['First line\\n', 'Second line\\n', 'Third line\\n']\n    \"\"\"\n    import os\n\n    if not isinstance(file_path, str):\n        raise ValueError(\"The file path must be a string.\")\n\n    if not os.path.exists(file_path):\n        raise FileNotFoundError(f\"The file at {file_path} does not exist.\")\n\n    if not os.access(file_path, os.R_OK):\n        raise PermissionError(f\"No permission to read the file at {file_path}.\")\n\n    with open(file_path, 'r', encoding='utf-8') as file:\n        lines = file.readlines()\n\n    return lines\n",
  "validate_email_format": "import re\nimport logging\n\ndef validate_email_format(email: str) -> bool:\n    \"\"\"\n    Validate the format of an email address.\n\n    Args:\n        email (str): The email address to validate.\n\n    Returns:\n        bool: True if the email format is valid, False otherwise.\n\n    Raises:\n        ValueError: If the input is not a string.\n\n    Example:\n        >>> validate_email_format(\"example@example.com\")\n        True\n        >>> validate_email_format(\"invalid-email\")\n        False\n    \"\"\"\n    if not isinstance(email, str):\n        raise ValueError(\"The email must be a string.\")\n\n    # Define a regular expression for validating an Email\n    email_regex = r'^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}$'\n\n    # Check if the email matches the regex pattern\n    is_valid = re.match(email_regex, email) is not None\n\n    # Log the result\n    logging.debug(f\"Email validation for '{email}': {is_valid}\")\n\n    return is_valid\n",
  "capitalize_words": "def capitalize_words(text: str) -> str:\n    \"\"\"\n    Capitalize the first letter of each word in a given string.\n\n    Args:\n        text (str): The input string to transform.\n\n    Returns:\n        str: A new string with the first letter of each word capitalized.\n\n    Raises:\n        ValueError: If the input is not a string.\n\n    Example:\n        >>> capitalize_words(\"hello world\")\n        'Hello World'\n        >>> capitalize_words(\"python programming\")\n        'Python Programming'\n    \"\"\"\n    if not isinstance(text, str):\n        raise ValueError(\"Input must be a string.\")\n\n    # Split the text into words, capitalize each word, and join them back\n    capitalized_text = ' '.join(word.capitalize() for word in text.split())\n\n    return capitalized_text\n",
  "find_unique_elements": "def find_unique_elements(elements: list) -> list:\n    \"\"\"\n    Find unique elements in a list.\n\n    Args:\n        elements (list): A list of elements to evaluate.\n\n    Returns:\n        list: A list containing only the unique elements from the input list.\n\n    Raises:\n        ValueError: If the input is not a list.\n\n    Example:\n        >>> find_unique_elements([1, 2, 2, 3, 4, 4, 5])\n        [1, 3, 5]\n        >>> find_unique_elements(['apple', 'banana', 'apple', 'cherry'])\n        ['banana', 'cherry']\n    \"\"\"\n    import logging\n\n    if not isinstance(elements, list):\n        raise ValueError(\"Input must be a list.\")\n\n    # Use a dictionary to count occurrences of each element\n    element_count = {}\n    for element in elements:\n        if element in element_count:\n            element_count[element] += 1\n        else:\n            element_count[element] = 1\n\n    # Extract elements that occur exactly once\n    unique_elements = [element for element, count in element_count.items() if count == 1]\n\n    # Log the result\n    logging.debug(f\"Unique elements found: {unique_elements}\")\n\n    return unique_elements\n",
  "calculate_average": "def calculate_average(numbers: list[float]) -> float:\n    \"\"\"\n    Calculate the average of a list of numbers.\n\n    Args:\n        numbers (list[float]): A list of numbers to calculate the average.\n\n    Returns:\n        float: The average of the numbers in the list.\n\n    Raises:\n        ValueError: If the input is not a list of numbers or if the list is empty.\n\n    Example:\n        >>> calculate_average([1.0, 2.0, 3.0, 4.0, 5.0])\n        3.0\n        >>> calculate_average([10, 20, 30])\n        20.0\n    \"\"\"\n    import logging\n\n    if not isinstance(numbers, list):\n        if isinstance(numbers, (int, float)):\n            numbers = [numbers]\n        else:\n            raise ValueError(\"Input must be a list of numbers or a single number.\")\n    \n    if not numbers:\n        raise ValueError(\"The list of numbers cannot be empty.\")\n    if not all(isinstance(num, (int, float)) for num in numbers):\n        raise ValueError(\"All elements in the list must be numbers (int or float).\")\n\n    total = sum(numbers)\n    count = len(numbers)\n    average = total / count\n\n    logging.debug(f\"Calculated average: {average}\")\n\n    return average",
  "find_max_min_difference": "def find_max_min_difference(numbers: list[float]) -> float:\n    \"\"\"\n    Calculate the difference between the maximum and minimum values in a list of numbers.\n\n    Args:\n        numbers (list[float]): A list of numbers to evaluate.\n\n    Returns:\n        float: The difference between the maximum and minimum numbers in the list.\n\n    Raises:\n        ValueError: If the input is not a list of numbers or if the list is empty.\n\n    Example:\n        >>> find_max_min_difference([10.0, 20.0, 30.0, 40.0])\n        30.0\n        >>> find_max_min_difference([5, 3, 8, 1])\n        7.0\n    \"\"\"\n    import logging\n\n    if isinstance(numbers, (int, float)):\n        numbers = [numbers]\n    \n    if not isinstance(numbers, list):\n        raise ValueError(\"Input must be a list of numbers.\")\n    \n    if not numbers:\n        raise ValueError(\"The list of numbers cannot be empty.\")\n    \n    if not all(isinstance(num, (int, float)) for num in numbers):\n        raise ValueError(\"All elements in the list must be numbers (int or float).\")\n\n    max_value = max(numbers)\n    min_value = min(numbers)\n    difference = max_value - min_value\n\n    logging.debug(f\"Max value: {max_value}, Min value: {min_value}, Difference: {difference}\")\n\n    return difference",
  "count_word_occurrences": "def count_word_occurrences(text: str) -> dict[str, int]:\n    \"\"\"\n    Count the occurrences of each word in a given string.\n\n    Args:\n        text (str): The input string to analyze.\n\n    Returns:\n        dict[str, int]: A dictionary with words as keys and their occurrence counts as values.\n\n    Raises:\n        ValueError: If the input is not a string.\n\n    Example:\n        >>> count_word_occurrences(\"hello world hello\")\n        {'hello': 2, 'world': 1}\n        >>> count_word_occurrences(\"Python is great and Python is fun\")\n        {'python': 2, 'is': 2, 'great': 1, 'and': 1, 'fun': 1}\n    \"\"\"\n    import logging\n\n    if not isinstance(text, str):\n        raise ValueError(\"Input must be a string.\")\n\n    # Convert text to lowercase and split into words\n    words = text.lower().split()\n\n    # Use a dictionary to count occurrences of each word\n    word_count = {}\n    for word in words:\n        if word in word_count:\n            word_count[word] += 1\n        else:\n            word_count[word] = 1\n\n    # Log the word count result\n    logging.debug(f\"Word occurrences: {word_count}\")\n\n    return word_count\n",
  "remove_punctuation": "def remove_punctuation(text: str) -> str:\n    \"\"\"\n    Remove all punctuation from a given string.\n\n    Args:\n        text (str): The input string from which to remove punctuation.\n\n    Returns:\n        str: A new string with all punctuation characters removed.\n\n    Raises:\n        ValueError: If the input is not a string.\n\n    Example:\n        >>> remove_punctuation(\"Hello, world!\")\n        'Hello world'\n        >>> remove_punctuation(\"Python's great, isn't it?\")\n        'Pythons great isnt it'\n    \"\"\"\n    import string\n    import logging\n\n    if not isinstance(text, str):\n        raise ValueError(\"Input must be a string.\")\n\n    # Create a translation table that maps punctuation to None\n    translator = str.maketrans('', '', string.punctuation)\n\n    # Remove punctuation using the translation table\n    cleaned_text = text.translate(translator)\n\n    # Log the cleaned text\n    logging.debug(f\"Original text: '{text}', Cleaned text: '{cleaned_text}'\")\n\n    return cleaned_text\n",
  "format_as_title_case": "def format_as_title_case(text: str) -> str:\n    \"\"\"\n    Convert a given string to title case, capitalizing the first letter of each word\n    while ensuring the rest of the letters are in lowercase.\n\n    Args:\n        text (str): The input string to be formatted.\n\n    Returns:\n        str: A new string with each word's first letter capitalized and the rest in lowercase.\n\n    Raises:\n        ValueError: If the input is not a string.\n\n    Example:\n        >>> format_as_title_case(\"hello world\")\n        'Hello World'\n        >>> format_as_title_case(\"PYTHON programming\")\n        'Python Programming'\n    \"\"\"\n    import logging\n\n    if not isinstance(text, str):\n        raise ValueError(\"Input must be a string.\")\n\n    # Convert the text to title case\n    title_cased_text = text.title()\n\n    # Log the transformation\n    logging.debug(f\"Original text: '{text}', Title-cased text: '{title_cased_text}'\")\n\n    return title_cased_text\n",
  "binary_search": "def binary_search(sorted_list: list[int], target: int) -> int:\n    \"\"\"\n    Perform a binary search on a sorted list to find the index of a target value.\n\n    Args:\n        sorted_list (list[int]): A list of integers sorted in ascending order.\n        target (int): The integer value to search for in the list.\n\n    Returns:\n        int: The index of the target value in the list if found, otherwise -1.\n\n    Raises:\n        ValueError: If the input list is not sorted or if the inputs are not of the correct type.\n\n    Example:\n        >>> binary_search([1, 2, 3, 4, 5], 3)\n        2\n        >>> binary_search([10, 20, 30, 40, 50], 25)\n        -1\n    \"\"\"\n    import logging\n\n    if not isinstance(sorted_list, list):\n        sorted_list = [sorted_list]\n    if not all(isinstance(x, int) for x in sorted_list):\n        raise ValueError(\"The sorted_list must be a list of integers.\")\n    if not isinstance(target, int):\n        raise ValueError(\"The target must be an integer.\")\n    if sorted_list != sorted(sorted_list):\n        raise ValueError(\"The list must be sorted in ascending order.\")\n\n    left, right = 0, len(sorted_list) - 1\n\n    while left <= right:\n        mid = (left + right) // 2\n        mid_value = sorted_list[mid]\n\n        logging.debug(f\"Searching: left={left}, right={right}, mid={mid}, mid_value={mid_value}\")\n\n        if mid_value == target:\n            return mid\n        elif mid_value < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n\n    return -1",
  "quicksort": "def quicksort(arr: list[int]) -> list[int]:\n    \"\"\"\n    Sort a list of integers using the quicksort algorithm.\n\n    Args:\n        arr (list[int]): A list of integers to be sorted.\n\n    Returns:\n        list[int]: A new list containing the sorted integers.\n\n    Raises:\n        ValueError: If the input is not a list of integers.\n\n    Example:\n        >>> quicksort([3, 6, 8, 10, 1, 2, 1])\n        [1, 1, 2, 3, 6, 8, 10]\n        >>> quicksort([5, 3, 8, 4, 2])\n        [2, 3, 4, 5, 8]\n    \"\"\"\n    import logging\n\n    if isinstance(arr, int):\n        arr = [arr]\n    elif not isinstance(arr, list):\n        raise ValueError(\"Input must be a list of integers.\")\n    if not all(isinstance(x, int) for x in arr):\n        raise ValueError(\"All elements in the list must be integers.\")\n\n    logging.debug(f\"Initial array: {arr}\")\n\n    def _quicksort(lst: list[int]) -> list[int]:\n        if len(lst) <= 1:\n            return lst\n        pivot = lst[len(lst) // 2]\n        left = [x for x in lst if x < pivot]\n        middle = [x for x in lst if x == pivot]\n        right = [x for x in lst if x > pivot]\n        logging.debug(f\"Pivot: {pivot}, Left: {left}, Middle: {middle}, Right: {right}\")\n        return _quicksort(left) + middle + _quicksort(right)\n\n    sorted_arr = _quicksort(arr)\n    logging.debug(f\"Sorted array: {sorted_arr}\")\n\n    return sorted_arr",
  "merge_sorted_lists": "def merge_sorted_lists(list1: list[int], list2: list[int]) -> list[int]:\n    \"\"\"\n    Merge two sorted lists into a single sorted list.\n\n    Args:\n        list1 (list[int]): The first sorted list of integers.\n        list2 (list[int]): The second sorted list of integers.\n\n    Returns:\n        list[int]: A new list containing all elements from both input lists, sorted in ascending order.\n\n    Raises:\n        ValueError: If either input is not a list of integers or if the lists are not sorted.\n\n    Example:\n        >>> merge_sorted_lists([1, 3, 5], [2, 4, 6])\n        [1, 2, 3, 4, 5, 6]\n        >>> merge_sorted_lists([1, 2, 3], [])\n        [1, 2, 3]\n    \"\"\"\n    import logging\n\n    # Convert single integers to lists\n    if isinstance(list1, int):\n        list1 = [list1]\n    if isinstance(list2, int):\n        list2 = [list2]\n\n    if not isinstance(list1, list) or not isinstance(list2, list):\n        raise ValueError(\"Both inputs must be lists of integers.\")\n    if not all(isinstance(x, int) for x in list1) or not all(isinstance(x, int) for x in list2):\n        raise ValueError(\"All elements in both lists must be integers.\")\n    if list1 != sorted(list1) or list2 != sorted(list2):\n        raise ValueError(\"Both lists must be sorted in ascending order.\")\n\n    logging.debug(f\"Merging lists: {list1} and {list2}\")\n\n    merged_list = []\n    i, j = 0, 0\n\n    while i < len(list1) and j < len(list2):\n        if list1[i] < list2[j]:\n            merged_list.append(list1[i])\n            i += 1\n        else:\n            merged_list.append(list2[j])\n            j += 1\n\n    # Append remaining elements\n    merged_list.extend(list1[i:])\n    merged_list.extend(list2[j:])\n\n    logging.debug(f\"Merged list: {merged_list}\")\n\n    return merged_list",
  "debug_variable_types": "def debug_variable_types(variables: dict[str, any]) -> dict[str, str]:\n    \"\"\"\n    Debug and return the types of given variables.\n\n    Args:\n        variables (dict[str, any]): A dictionary where keys are variable names and values are the variables themselves.\n\n    Returns:\n        dict[str, str]: A dictionary with variable names as keys and their types as values.\n\n    Raises:\n        ValueError: If the input is not a dictionary or if any key is not a string.\n\n    Example:\n        >>> debug_variable_types({'var1': 123, 'var2': 'hello', 'var3': [1, 2, 3]})\n        {'var1': 'int', 'var2': 'str', 'var3': 'list'}\n    \"\"\"\n    import logging\n\n    if not isinstance(variables, dict):\n        if isinstance(variables, (str, int, float, list, tuple, set)):\n            variables = {'value': variables}\n        else:\n            raise ValueError(\"Input must be a dictionary with variable names as keys.\")\n\n    for key in variables:\n        if not isinstance(key, str):\n            raise ValueError(\"All keys in the dictionary must be strings representing variable names.\")\n\n    types_dict = {var_name: type(var_value).__name__ for var_name, var_value in variables.items()}\n\n    logging.debug(f\"Variable types: {types_dict}\")\n\n    return types_dict",
  "remove_whitespace": "def remove_whitespace(text: str) -> str:\n    \"\"\"\n    Remove all whitespace characters from a given string.\n\n    Args:\n        text (str): The input string from which to remove whitespace.\n\n    Returns:\n        str: A new string with all whitespace characters removed.\n\n    Raises:\n        ValueError: If the input is not a string.\n\n    Example:\n        >>> remove_whitespace(\"Hello, world!\")\n        'Hello,world!'\n        >>> remove_whitespace(\" Python  programming \")\n        'Pythonprogramming'\n    \"\"\"\n    import logging\n\n    if not isinstance(text, str):\n        raise ValueError(\"Input must be a string.\")\n\n    # Remove all whitespace characters\n    cleaned_text = ''.join(text.split())\n\n    # Log the cleaned text\n    logging.debug(f\"Original text: '{text}', Cleaned text: '{cleaned_text}'\")\n\n    return cleaned_text\n",
  "normalize_text": "def normalize_text(text: str) -> str:\n    \"\"\"\n    Normalize a given string by converting it to lowercase and removing extra spaces.\n\n    Args:\n        text (str): The input string to normalize.\n\n    Returns:\n        str: A normalized string with all characters in lowercase and extra spaces removed.\n\n    Raises:\n        ValueError: If the input is not a string.\n\n    Example:\n        >>> normalize_text(\"  Hello,   WORLD!  \")\n        'hello, world!'\n        >>> normalize_text(\"Python   Programming\")\n        'python programming'\n    \"\"\"\n    import logging\n\n    if not isinstance(text, str):\n        raise ValueError(\"Input must be a string.\")\n\n    # Convert text to lowercase\n    lower_text = text.lower()\n\n    # Remove extra spaces\n    normalized_text = ' '.join(lower_text.split())\n\n    # Log the normalization process\n    logging.debug(f\"Original text: '{text}', Normalized text: '{normalized_text}'\")\n\n    return normalized_text\n",
  "calculate_median": "def calculate_median(numbers: list[float]) -> float:\n    \"\"\"\n    Calculate the median of a list of numbers.\n\n    The median is the middle value in a list of numbers. If the list has an even number of elements,\n    the median is the average of the two middle numbers.\n\n    Args:\n        numbers (list[float]): A list of numbers to calculate the median.\n\n    Returns:\n        float: The median of the numbers in the list.\n\n    Raises:\n        ValueError: If the input is not a list of numbers or if the list is empty.\n\n    Example:\n        >>> calculate_median([1, 3, 3, 6, 7, 8, 9])\n        6.0\n        >>> calculate_median([1, 2, 3, 4, 5, 6, 8, 9])\n        4.5\n    \"\"\"\n    import logging\n\n    if not isinstance(numbers, list):\n        numbers = [numbers]\n    if not numbers:\n        raise ValueError(\"The list of numbers cannot be empty.\")\n    if not all(isinstance(num, (int, float)) for num in numbers):\n        raise ValueError(\"All elements in the list must be numbers (int or float).\")\n\n    sorted_numbers = sorted(numbers)\n    n = len(sorted_numbers)\n    mid = n // 2\n\n    if n % 2 == 0:\n        median = (sorted_numbers[mid - 1] + sorted_numbers[mid]) / 2.0\n    else:\n        median = sorted_numbers[mid]\n\n    logging.debug(f\"Sorted numbers: {sorted_numbers}, Median: {median}\")\n\n    return median",
  "validate_phone_number_format": "def validate_phone_number_format(phone_number: str) -> bool:\n    \"\"\"\n    Validate the format of a phone number.\n\n    This function checks if the phone number follows a standard format, such as\n    (XXX) XXX-XXXX or XXX-XXX-XXXX, where X is a digit.\n\n    Args:\n        phone_number (str): The phone number to validate.\n\n    Returns:\n        bool: True if the phone number format is valid, False otherwise.\n\n    Raises:\n        ValueError: If the input is not a string.\n\n    Example:\n        >>> validate_phone_number_format(\"(123) 456-7890\")\n        True\n        >>> validate_phone_number_format(\"123-456-7890\")\n        True\n        >>> validate_phone_number_format(\"1234567890\")\n        False\n    \"\"\"\n    import re\n    import logging\n\n    if not isinstance(phone_number, str):\n        raise ValueError(\"The phone number must be a string.\")\n\n    # Define a regular expression for validating phone numbers\n    phone_regex = r'^\\(?\\d{3}\\)?[-.\\s]?\\d{3}[-.\\s]?\\d{4}$'\n\n    # Check if the phone number matches the regex pattern\n    is_valid = re.match(phone_regex, phone_number) is not None\n\n    # Log the result\n    logging.debug(f\"Phone number validation for '{phone_number}': {is_valid}\")\n\n    return is_valid\n",
  "convert_to_snake_case": "def convert_to_snake_case(text: str) -> str:\n    \"\"\"\n    Convert a given string to snake_case format.\n\n    This function transforms a string into snake_case, where words are\n    separated by underscores and all letters are in lowercase.\n\n    Args:\n        text (str): The input string to convert.\n\n    Returns:\n        str: A new string in snake_case format.\n\n    Raises:\n        ValueError: If the input is not a string.\n\n    Example:\n        >>> convert_to_snake_case(\"Hello World\")\n        'hello_world'\n        >>> convert_to_snake_case(\"PythonProgramming\")\n        'python_programming'\n    \"\"\"\n    import re\n    import logging\n\n    if not isinstance(text, str):\n        raise ValueError(\"Input must be a string.\")\n\n    # Replace spaces and hyphens with underscores\n    text = re.sub(r'[\\s-]+', '_', text)\n\n    # Convert camelCase or PascalCase to snake_case\n    text = re.sub(r'(?<!^)(?=[A-Z])', '_', text).lower()\n\n    # Log the transformation\n    logging.debug(f\"Original text: '{text}', Snake_case text: '{text}'\")\n\n    return text\n",
  "flatten_nested_list": "def flatten_nested_list(nested_list: list) -> list:\n    \"\"\"\n    Flatten a nested list into a single list of elements.\n\n    This function takes a list that may contain nested lists and flattens it into a single list\n    containing all the elements in a depth-first manner.\n\n    Args:\n        nested_list (list): A list that may contain nested lists of elements.\n\n    Returns:\n        list: A flattened list containing all elements from the nested list.\n\n    Raises:\n        ValueError: If the input is not a list.\n\n    Example:\n        >>> flatten_nested_list([1, [2, [3, 4], 5], 6])\n        [1, 2, 3, 4, 5, 6]\n        >>> flatten_nested_list([[1, 2], [3, 4], 5])\n        [1, 2, 3, 4, 5]\n    \"\"\"\n    import logging\n\n    if not isinstance(nested_list, list):\n        raise ValueError(\"Input must be a list.\")\n\n    def _flatten(lst: list) -> list:\n        flat_list = []\n        for item in lst:\n            if isinstance(item, list):\n                flat_list.extend(_flatten(item))\n            else:\n                flat_list.append(item)\n        return flat_list\n\n    flattened_list = _flatten(nested_list)\n\n    logging.debug(f\"Original nested list: {nested_list}, Flattened list: {flattened_list}\")\n\n    return flattened_list\n",
  "calculate_mode": "def calculate_mode(numbers: list[float]) -> list[float]:\n    \"\"\"\n    Calculate the mode(s) of a list of numbers.\n\n    The mode is the number that appears most frequently in a list. If multiple numbers have the same highest frequency,\n    all of them are returned.\n\n    Args:\n        numbers (list[float]): A list of numbers to calculate the mode.\n\n    Returns:\n        list[float]: A list containing the mode(s) of the numbers in the list.\n\n    Raises:\n        ValueError: If the input is not a list of numbers or if the list is empty.\n\n    Example:\n        >>> calculate_mode([1, 2, 2, 3, 4, 4, 4, 5])\n        [4]\n        >>> calculate_mode([1, 1, 2, 2, 3])\n        [1, 2]\n    \"\"\"\n    import logging\n    from collections import Counter\n\n    if not isinstance(numbers, list):\n        numbers = [numbers]\n    if not numbers:\n        raise ValueError(\"The list of numbers cannot be empty.\")\n    if not all(isinstance(num, (int, float)) for num in numbers):\n        raise ValueError(\"All elements in the list must be numbers (int or float).\")\n\n    # Count the frequency of each number\n    frequency = Counter(numbers)\n    max_count = max(frequency.values())\n    modes = [num for num, count in frequency.items() if count == max_count]\n\n    logging.debug(f\"Number frequencies: {frequency}, Modes: {modes}\")\n\n    return modes",
  "optimize_list_order": "def optimize_list_order(numbers: list[int]) -> list[int]:\n    \"\"\"\n    Optimize the order of a list of integers by sorting them in ascending order\n    and removing duplicates.\n\n    This function sorts a list of integers in ascending order and removes any duplicate values,\n    ensuring that each number appears only once in the resulting list.\n\n    Args:\n        numbers (list[int]): A list of integers to be optimized.\n\n    Returns:\n        list[int]: A new list containing the sorted integers with duplicates removed.\n\n    Raises:\n        ValueError: If the input is not a list of integers.\n\n    Example:\n        >>> optimize_list_order([4, 2, 5, 2, 3, 1, 4])\n        [1, 2, 3, 4, 5]\n        >>> optimize_list_order([10, 9, 8, 8, 7])\n        [7, 8, 9, 10]\n    \"\"\"\n    import logging\n\n    if isinstance(numbers, int):\n        numbers = [numbers]\n    elif not isinstance(numbers, list):\n        raise ValueError(\"Input must be a list of integers or a single integer.\")\n    if not all(isinstance(num, int) for num in numbers):\n        raise ValueError(\"All elements in the list must be integers.\")\n\n    # Remove duplicates by converting to a set, then sort the result\n    optimized_list = sorted(set(numbers))\n\n    logging.debug(f\"Original list: {numbers}, Optimized list: {optimized_list}\")\n\n    return optimized_list",
  "convert_to_camel_case": "def convert_to_camel_case(text: str) -> str:\n    \"\"\"\n    Convert a given string to camelCase format.\n\n    This function transforms a string into camelCase, where the first word is in lowercase\n    and subsequent words are capitalized without spaces or underscores.\n\n    Args:\n        text (str): The input string to convert.\n\n    Returns:\n        str: A new string in camelCase format.\n\n    Raises:\n        ValueError: If the input is not a string.\n\n    Example:\n        >>> convert_to_camel_case(\"hello world\")\n        'helloWorld'\n        >>> convert_to_camel_case(\"python programming language\")\n        'pythonProgrammingLanguage'\n    \"\"\"\n    import re\n    import logging\n\n    if not isinstance(text, str):\n        raise ValueError(\"Input must be a string.\")\n\n    # Remove any non-alphanumeric characters and split the text into words\n    words = re.sub(r'[^a-zA-Z0-9\\s]', '', text).split()\n\n    # Convert the first word to lowercase and capitalize the rest\n    if not words:\n        return ''\n    \n    camel_case_text = words[0].lower() + ''.join(word.capitalize() for word in words[1:])\n\n    # Log the transformation\n    logging.debug(f\"Original text: '{text}', CamelCase text: '{camel_case_text}'\")\n\n    return camel_case_text\n",
  "count_vowels_consonants": "def count_vowels_consonants(text: str) -> dict[str, int]:\n    \"\"\"\n    Count the number of vowels and consonants in a given string.\n\n    This function calculates the number of vowels and consonants in the input string,\n    ignoring any non-alphabetic characters.\n\n    Args:\n        text (str): The input string to analyze.\n\n    Returns:\n        dict[str, int]: A dictionary with keys 'vowels' and 'consonants' representing\n                        the count of vowels and consonants, respectively.\n\n    Raises:\n        ValueError: If the input is not a string.\n\n    Example:\n        >>> count_vowels_consonants(\"Hello World!\")\n        {'vowels': 3, 'consonants': 7}\n        >>> count_vowels_consonants(\"Python 3.8\")\n        {'vowels': 1, 'consonants': 5}\n    \"\"\"\n    import logging\n\n    if not isinstance(text, str):\n        raise ValueError(\"Input must be a string.\")\n\n    vowels = set(\"aeiouAEIOU\")\n    consonants = set(\"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\")\n\n    vowel_count = sum(1 for char in text if char in vowels)\n    consonant_count = sum(1 for char in text if char in consonants)\n\n    result = {'vowels': vowel_count, 'consonants': consonant_count}\n\n    logging.debug(f\"Text: '{text}', Vowels: {vowel_count}, Consonants: {consonant_count}\")\n\n    return result\n",
  "convert_to_kebab_case": "def convert_to_kebab_case(text: str) -> str:\n    \"\"\"\n    Convert a given string to kebab-case format.\n\n    This function transforms a string into kebab-case, where words are\n    separated by hyphens and all letters are in lowercase.\n\n    Args:\n        text (str): The input string to convert.\n\n    Returns:\n        str: A new string in kebab-case format.\n\n    Raises:\n        ValueError: If the input is not a string.\n\n    Example:\n        >>> convert_to_kebab_case(\"Hello World\")\n        'hello-world'\n        >>> convert_to_kebab_case(\"PythonProgramming\")\n        'python-programming'\n    \"\"\"\n    import re\n    import logging\n\n    if not isinstance(text, str):\n        raise ValueError(\"Input must be a string.\")\n\n    # Replace spaces and underscores with hyphens\n    text = re.sub(r'[\\s_]+', '-', text)\n\n    # Convert camelCase or PascalCase to kebab-case\n    text = re.sub(r'(?<!^)(?=[A-Z])', '-', text).lower()\n\n    # Log the transformation\n    logging.debug(f\"Original text: '{text}', Kebab-case text: '{text}'\")\n\n    return text\n",
  "format_as_sentence_case": "def format_as_sentence_case(text: str) -> str:\n    \"\"\"\n    Convert a given string to sentence case, capitalizing the first letter of the first word\n    and ensuring the rest of the sentence is in lowercase.\n\n    Args:\n        text (str): The input string to be formatted.\n\n    Returns:\n        str: A new string with the first letter of the first word capitalized and the rest in lowercase.\n\n    Raises:\n        ValueError: If the input is not a string.\n\n    Example:\n        >>> format_as_sentence_case(\"hello world. THIS IS a TEST.\")\n        'Hello world. this is a test.'\n        >>> format_as_sentence_case(\"PYTHON programming.\")\n        'Python programming.'\n    \"\"\"\n    import logging\n\n    if not isinstance(text, str):\n        raise ValueError(\"Input must be a string.\")\n\n    # Split the text into sentences\n    sentences = text.split('. ')\n    formatted_sentences = []\n\n    for sentence in sentences:\n        if sentence:\n            # Capitalize the first letter of the sentence and make the rest lowercase\n            formatted_sentence = sentence[0].upper() + sentence[1:].lower()\n            formatted_sentences.append(formatted_sentence)\n\n    # Join the sentences back together\n    sentence_cased_text = '. '.join(formatted_sentences)\n\n    # Log the transformation\n    logging.debug(f\"Original text: '{text}', Sentence-cased text: '{sentence_cased_text}'\")\n\n    return sentence_cased_text\n",
  "linear_search": "def linear_search(elements: list[int], target: int) -> int:\n    \"\"\"\n    Perform a linear search on a list to find the index of a target value.\n\n    This function iterates through the list to find the first occurrence of the target value.\n    It returns the index of the target if found, otherwise returns -1.\n\n    Args:\n        elements (list[int]): A list of integers to search through.\n        target (int): The integer value to search for in the list.\n\n    Returns:\n        int: The index of the target value in the list if found, otherwise -1.\n\n    Raises:\n        ValueError: If the input list is not a list of integers or if the target is not an integer.\n\n    Example:\n        >>> linear_search([10, 20, 30, 40, 50], 30)\n        2\n        >>> linear_search([5, 3, 8, 1], 7)\n        -1\n    \"\"\"\n    import logging\n\n    if not isinstance(elements, list):\n        elements = [elements]\n    if not all(isinstance(x, int) for x in elements):\n        raise ValueError(\"All elements in the list must be integers.\")\n    if not isinstance(target, int):\n        raise ValueError(\"The target must be an integer.\")\n\n    logging.debug(f\"Starting linear search for target {target} in list: {elements}\")\n\n    for index, value in enumerate(elements):\n        logging.debug(f\"Checking index {index}: value {value}\")\n        if value == target:\n            logging.debug(f\"Target {target} found at index {index}\")\n            return index\n\n    logging.debug(f\"Target {target} not found in the list\")\n    return -1",
  "merge_sort": "def merge_sort(arr: list[int]) -> list[int]:\n    \"\"\"\n    Sort a list of integers using the merge sort algorithm.\n\n    Merge sort is a divide-and-conquer algorithm that splits the list into halves,\n    recursively sorts each half, and then merges the sorted halves back together.\n\n    Args:\n        arr (list[int]): A list of integers to be sorted.\n\n    Returns:\n        list[int]: A new list containing the sorted integers.\n\n    Raises:\n        ValueError: If the input is not a list of integers.\n\n    Example:\n        >>> merge_sort([3, 6, 8, 10, 1, 2, 1])\n        [1, 1, 2, 3, 6, 8, 10]\n        >>> merge_sort([5, 3, 8, 4, 2])\n        [2, 3, 4, 5, 8]\n    \"\"\"\n    import logging\n\n    if isinstance(arr, int):\n        arr = [arr]\n    elif not isinstance(arr, list):\n        raise ValueError(\"Input must be a list of integers.\")\n    if not all(isinstance(x, int) for x in arr):\n        raise ValueError(\"All elements in the list must be integers.\")\n\n    logging.debug(f\"Initial array: {arr}\")\n\n    def _merge(left: list[int], right: list[int]) -> list[int]:\n        result = []\n        i = j = 0\n        while i < len(left) and j < len(right):\n            if left[i] < right[j]:\n                result.append(left[i])\n                i += 1\n            else:\n                result.append(right[j])\n                j += 1\n        result.extend(left[i:])\n        result.extend(right[j:])\n        return result\n\n    def _merge_sort(lst: list[int]) -> list[int]:\n        if len(lst) <= 1:\n            return lst\n        mid = len(lst) // 2\n        left = _merge_sort(lst[:mid])\n        right = _merge_sort(lst[mid:])\n        return _merge(left, right)\n\n    sorted_arr = _merge_sort(arr)\n    logging.debug(f\"Sorted array: {sorted_arr}\")\n\n    return sorted_arr\n",
  "find_longest_common_prefix": "def find_longest_common_prefix(strings: list[str]) -> str:\n    \"\"\"\n    Find the longest common prefix among a list of strings.\n\n    This function identifies the longest prefix that is common to all strings in the input list.\n    If no common prefix exists, it returns an empty string.\n\n    Args:\n        strings (list[str]): A list of strings to evaluate.\n\n    Returns:\n        str: The longest common prefix shared by all strings in the list.\n\n    Raises:\n        ValueError: If the input is not a list of strings or if the list is empty.\n\n    Example:\n        >>> find_longest_common_prefix([\"flower\", \"flow\", \"flight\"])\n        'fl'\n        >>> find_longest_common_prefix([\"dog\", \"racecar\", \"car\"])\n        ''\n    \"\"\"\n    import logging\n\n    if isinstance(strings, str):\n        strings = [strings]\n    elif not isinstance(strings, list):\n        raise ValueError(\"Input must be a list of strings.\")\n    if not strings:\n        raise ValueError(\"The list of strings cannot be empty.\")\n    if not all(isinstance(s, str) for s in strings):\n        raise ValueError(\"All elements in the list must be strings.\")\n\n    logging.debug(f\"Finding longest common prefix for strings: {strings}\")\n\n    if len(strings) == 1:\n        return strings[0]\n\n    # Sort the list to bring similar prefixes together\n    strings.sort()\n\n    # Compare the first and last strings in the sorted list\n    first, last = strings[0], strings[-1]\n    common_prefix = []\n\n    for i in range(min(len(first), len(last))):\n        if first[i] == last[i]:\n            common_prefix.append(first[i])\n        else:\n            break\n\n    result = ''.join(common_prefix)\n    logging.debug(f\"Longest common prefix: '{result}'\")\n\n    return result",
  "debug_list_structure": "def debug_list_structure(data: list) -> dict[str, any]:\n    \"\"\"\n    Analyze the structure of a list, providing details about its elements, including types and nested levels.\n\n    This function inspects a list and returns a dictionary containing information about the types of elements,\n    the depth of nesting, and the count of each type of element.\n\n    Args:\n        data (list): The list to analyze.\n\n    Returns:\n        dict[str, any]: A dictionary with keys 'element_types', 'max_depth', and 'type_counts' providing\n                        details about the list structure.\n\n    Raises:\n        ValueError: If the input is not a list.\n\n    Example:\n        >>> debug_list_structure([1, \"text\", [2, 3], {\"key\": \"value\"}])\n        {'element_types': ['int', 'str', 'list', 'dict'], 'max_depth': 2, 'type_counts': {'int': 1, 'str': 1, 'list': 1, 'dict': 1}}\n    \"\"\"\n    import logging\n    from collections import defaultdict\n\n    if not isinstance(data, list):\n        raise ValueError(\"Input must be a list.\")\n\n    def analyze_structure(lst: list, depth: int = 0) -> tuple[set, int, defaultdict]:\n        element_types = set()\n        max_depth = depth\n        type_counts = defaultdict(int)\n\n        for element in lst:\n            element_type = type(element).__name__\n            element_types.add(element_type)\n            type_counts[element_type] += 1\n\n            if isinstance(element, list):\n                sub_types, sub_depth, sub_counts = analyze_structure(element, depth + 1)\n                element_types.update(sub_types)\n                max_depth = max(max_depth, sub_depth)\n                for key, value in sub_counts.items():\n                    type_counts[key] += value\n\n        return element_types, max_depth, type_counts\n\n    element_types, max_depth, type_counts = analyze_structure(data)\n\n    result = {\n        'element_types': list(element_types),\n        'max_depth': max_depth,\n        'type_counts': dict(type_counts)\n    }\n\n    logging.debug(f\"list structure analysis: {result}\")\n\n    return result\n",
  "find_duplicates": "def find_duplicates(elements: list[int]) -> list[int]:\n    \"\"\"\n    Identify duplicate elements in a list of integers.\n\n    This function scans through a list of integers and returns a list of elements\n    that appear more than once. The returned list contains each duplicate element\n    only once, regardless of how many times it appears in the input list.\n\n    Args:\n        elements (list[int]): A list of integers to check for duplicates.\n\n    Returns:\n        list[int]: A list containing the duplicate integers found in the input list.\n\n    Raises:\n        ValueError: If the input is not a list of integers.\n\n    Example:\n        >>> find_duplicates([1, 2, 3, 2, 4, 5, 5, 6])\n        [2, 5]\n        >>> find_duplicates([10, 20, 30, 40])\n        []\n    \"\"\"\n    import logging\n    from collections import Counter\n\n    if not isinstance(elements, list):\n        elements = [elements]\n    if not all(isinstance(x, int) for x in elements):\n        raise ValueError(\"All elements in the list must be integers.\")\n\n    logging.debug(f\"Analyzing list for duplicates: {elements}\")\n\n    # Count the occurrences of each element\n    element_count = Counter(elements)\n\n    # Extract elements that appear more than once\n    duplicates = [element for element, count in element_count.items() if count > 1]\n\n    logging.debug(f\"Duplicate elements found: {duplicates}\")\n\n    return duplicates",
  "hash_password": "def hash_password(password: str, salt: str = None) -> dict[str, str]:\n    \"\"\"\n    Hash a password using SHA-256 with an optional salt.\n\n    This function takes a password and an optional salt, hashes the password using the SHA-256 algorithm,\n    and returns the hashed password along with the salt used. If no salt is provided, a random salt is generated.\n\n    Args:\n        password (str): The password to be hashed.\n        salt (str, optional): An optional salt to use for hashing. If not provided, a random salt is generated.\n\n    Returns:\n        dict[str, str]: A dictionary containing the 'salt' and the 'hashed_password'.\n\n    Raises:\n        ValueError: If the password is not a string or if the salt is provided and is not a string.\n\n    Example:\n        >>> hash_password(\"my_secure_password\")\n        {'salt': 'randomly_generated_salt', 'hashed_password': 'hashed_value'}\n        >>> hash_password(\"my_secure_password\", \"custom_salt\")\n        {'salt': 'custom_salt', 'hashed_password': 'hashed_value'}\n    \"\"\"\n    import hashlib\n    import os\n    import logging\n\n    if not isinstance(password, str):\n        raise ValueError(\"Password must be a string.\")\n    if salt is not None and not isinstance(salt, str):\n        raise ValueError(\"Salt must be a string if provided.\")\n\n    # Generate a random salt if not provided\n    if salt is None:\n        salt = os.urandom(16).hex()\n\n    # Create the hash using SHA-256\n    hash_obj = hashlib.sha256()\n    hash_obj.update((salt + password).encode('utf-8'))\n    hashed_password = hash_obj.hexdigest()\n\n    result = {'salt': salt, 'hashed_password': hashed_password}\n\n    logging.debug(f\"Password hashing: salt={salt}, hashed_password={hashed_password}\")\n\n    return result\n",
  "find_palindromes": "def find_palindromes(text: str) -> list[str]:\n    \"\"\"\n    Identify all palindromic words in a given string.\n\n    This function scans through the input string and returns a list of words\n    that are palindromes. A palindrome is a word that reads the same backward\n    as forward, ignoring case.\n\n    Args:\n        text (str): The input string to analyze.\n\n    Returns:\n        list[str]: A list containing all palindromic words found in the input string.\n\n    Raises:\n        ValueError: If the input is not a string.\n\n    Example:\n        >>> find_palindromes(\"Anna went to see civic duty in the noon\")\n        ['Anna', 'civic', 'noon']\n        >>> find_palindromes(\"Hello world\")\n        []\n    \"\"\"\n    import logging\n    import re\n\n    if not isinstance(text, str):\n        raise ValueError(\"Input must be a string.\")\n\n    # Use regex to find words in the text\n    words = re.findall(r'\\b\\w+\\b', text)\n\n    # Identify palindromes\n    palindromes = [word for word in words if word.lower() == word[::-1].lower()]\n\n    # Log the found palindromes\n    logging.debug(f\"Text: '{text}', Palindromes: {palindromes}\")\n\n    return palindromes\n",
  "group_anagrams": "def group_anagrams(words: list[str]) -> list[list[str]]:\n    \"\"\"\n    Group a list of words into anagrams.\n\n    This function takes a list of words and groups them into lists of anagrams.\n    An anagram is a word formed by rearranging the letters of another word.\n\n    Args:\n        words (list[str]): A list of words to group into anagrams.\n\n    Returns:\n        list[list[str]]: A list of lists, where each sublist contains words that are anagrams of each other.\n\n    Raises:\n        ValueError: If the input is not a list of strings.\n\n    Example:\n        >>> group_anagrams([\"listen\", \"silent\", \"enlist\", \"rat\", \"tar\", \"art\"])\n        [['listen', 'silent', 'enlist'], ['rat', 'tar', 'art']]\n        >>> group_anagrams([\"hello\", \"world\"])\n        [['hello'], ['world']]\n    \"\"\"\n    import logging\n    from collections import defaultdict\n\n    if not isinstance(words, list):\n        words = [words]\n    if not all(isinstance(word, str) for word in words):\n        raise ValueError(\"All elements in the list must be strings.\")\n\n    logging.debug(f\"Grouping anagrams from the list: {words}\")\n\n    anagrams = defaultdict(list)\n    for word in words:\n        # Sort the word to create a key\n        sorted_word = ''.join(sorted(word))\n        anagrams[sorted_word].append(word)\n\n    grouped_anagrams = list(anagrams.values())\n\n    logging.debug(f\"Grouped anagrams: {grouped_anagrams}\")\n\n    return grouped_anagrams",
  "calculate_standard_deviation": "def calculate_standard_deviation(numbers: list[float]) -> float:\n    \"\"\"\n    Calculate the standard deviation of a list of numbers.\n\n    The standard deviation is a measure of the amount of variation or dispersion in a set of values.\n    A low standard deviation indicates that the values tend to be close to the mean of the set,\n    while a high standard deviation indicates that the values are spread out over a wider range.\n\n    Args:\n        numbers (list[float]): A list of numbers to calculate the standard deviation.\n\n    Returns:\n        float: The standard deviation of the numbers in the list.\n\n    Raises:\n        ValueError: If the input is not a list of numbers or if the list is empty.\n\n    Example:\n        >>> calculate_standard_deviation([1.0, 2.0, 3.0, 4.0, 5.0])\n        1.4142135623730951\n        >>> calculate_standard_deviation([10, 12, 23, 23, 16, 23, 21, 16])\n        4.898979485566356\n    \"\"\"\n    import logging\n    import math\n\n    if not isinstance(numbers, list):\n        numbers = [numbers]\n    if not numbers:\n        raise ValueError(\"The list of numbers cannot be empty.\")\n    if not all(isinstance(num, (int, float)) for num in numbers):\n        raise ValueError(\"All elements in the list must be numbers (int or float).\")\n\n    mean = sum(numbers) / len(numbers)\n    variance = sum((x - mean) ** 2 for x in numbers) / len(numbers)\n    standard_deviation = math.sqrt(variance)\n\n    logging.debug(f\"Numbers: {numbers}, Mean: {mean}, Variance: {variance}, Standard Deviation: {standard_deviation}\")\n\n    return standard_deviation\n",
  "validate_url_format": "def validate_url_format(url: str) -> bool:\n    \"\"\"\n    Validate the format of a URL.\n\n    This function checks if the URL follows a standard format, including the scheme (http, https),\n    domain, and optional path, query, and fragment components.\n\n    Args:\n        url (str): The URL to validate.\n\n    Returns:\n        bool: True if the URL format is valid, False otherwise.\n\n    Raises:\n        ValueError: If the input is not a string.\n\n    Example:\n        >>> validate_url_format(\"https://www.example.com\")\n        True\n        >>> validate_url_format(\"ftp://example.com\")\n        False\n    \"\"\"\n    import re\n    import logging\n\n    if not isinstance(url, str):\n        raise ValueError(\"The URL must be a string.\")\n\n    # Define a regular expression for validating URLs\n    url_regex = (\n        r'^(https?://)'  # http:// or https://\n        r'(([A-Za-z0-9-]+\\.)+[A-Za-z]{2,6})'  # Domain name\n        r'(:\\d+)?'  # Optional port\n        r'(/[-A-Za-z0-9@:%._\\+~#=]*)*'  # Path\n        r'(\\?[;&A-Za-z0-9%_.~+=-]*)?'  # Query\n        r'(#[-A-Za-z0-9_]*)?$'  # Fragment\n    )\n\n    # Check if the URL matches the regex pattern\n    is_valid = re.match(url_regex, url) is not None\n\n    # Log the result\n    logging.debug(f\"URL validation for '{url}': {is_valid}\")\n\n    return is_valid\n",
  "transform_to_pig_latin": "def transform_to_pig_latin(text: str) -> str:\n    \"\"\"\n    Transform a given string into Pig Latin.\n\n    Pig Latin is a language game where words in English are altered according to a simple set of rules:\n    - For words that begin with a consonant, all letters before the initial vowel are placed at the end of the word sequence.\n      Then, \"ay\" is added.\n    - For words that begin with a vowel, \"way\" is added to the end of the word.\n\n    Args:\n        text (str): The input string to transform into Pig Latin.\n\n    Returns:\n        str: A new string with each word transformed into Pig Latin.\n\n    Raises:\n        ValueError: If the input is not a string.\n\n    Example:\n        >>> transform_to_pig_latin(\"hello world\")\n        'ellohay orldway'\n        >>> transform_to_pig_latin(\"apple\")\n        'appleway'\n    \"\"\"\n    import logging\n    import re\n\n    if not isinstance(text, str):\n        raise ValueError(\"Input must be a string.\")\n\n    def pig_latin_word(word: str) -> str:\n        vowels = \"aeiouAEIOU\"\n        if word[0] in vowels:\n            return word + \"way\"\n        else:\n            match = re.search(r\"[aeiouAEIOU]\", word)\n            if match:\n                index = match.start()\n                return word[index:] + word[:index] + \"ay\"\n            else:\n                return word + \"ay\"\n\n    words = text.split()\n    pig_latin_words = [pig_latin_word(word) for word in words]\n    pig_latin_text = ' '.join(pig_latin_words)\n\n    logging.debug(f\"Original text: '{text}', Pig Latin text: '{pig_latin_text}'\")\n\n    return pig_latin_text\n",
  "convert_to_hex": "def convert_to_hex(number: int) -> str:\n    \"\"\"\n    Convert an integer to its hexadecimal representation.\n\n    This function takes an integer and converts it to a hexadecimal string prefixed with '0x'.\n    It handles both positive and negative integers.\n\n    Args:\n        number (int): The integer to convert to hexadecimal.\n\n    Returns:\n        str: The hexadecimal representation of the integer.\n\n    Raises:\n        ValueError: If the input is not an integer.\n\n    Example:\n        >>> convert_to_hex(255)\n        '0xff'\n        >>> convert_to_hex(-42)\n        '-0x2a'\n    \"\"\"\n    import logging\n\n    if not isinstance(number, int):\n        raise ValueError(\"Input must be an integer.\")\n\n    hex_representation = hex(number)\n\n    logging.debug(f\"Converted integer {number} to hexadecimal: {hex_representation}\")\n\n    return hex_representation\n",
  "optimize_string_list": "def optimize_string_list(strings: list[str]) -> list[str]:\n    \"\"\"\n    Optimize a list of strings by removing duplicates and sorting them alphabetically.\n\n    This function takes a list of strings, removes any duplicate entries, and returns a new list\n    with the strings sorted in alphabetical order. The function ensures that each string appears\n    only once in the resulting list.\n\n    Args:\n        strings (list[str]): A list of strings to be optimized.\n\n    Returns:\n        list[str]: A new list containing the unique strings sorted alphabetically.\n\n    Raises:\n        ValueError: If the input is not a list of strings.\n\n    Example:\n        >>> optimize_string_list([\"apple\", \"banana\", \"apple\", \"cherry\"])\n        ['apple', 'banana', 'cherry']\n        >>> optimize_string_list([\"dog\", \"cat\", \"bird\", \"cat\"])\n        ['bird', 'cat', 'dog']\n    \"\"\"\n    import logging\n\n    if isinstance(strings, str):\n        strings = [strings]\n    elif not isinstance(strings, list):\n        raise ValueError(\"Input must be a list of strings or a single string.\")\n    if not all(isinstance(s, str) for s in strings):\n        raise ValueError(\"All elements in the list must be strings.\")\n\n    # Remove duplicates by converting to a set, then sort the result\n    optimized_list = sorted(set(strings))\n\n    logging.debug(f\"Original list: {strings}, Optimized list: {optimized_list}\")\n\n    return optimized_list",
  "find_longest_word": "def find_longest_word(text: str) -> str:\n    \"\"\"\n    Find the longest word in a given string.\n\n    This function scans through the input string and returns the longest word found.\n    If there are multiple words with the same maximum length, the first one encountered is returned.\n\n    Args:\n        text (str): The input string to analyze.\n\n    Returns:\n        str: The longest word in the input string.\n\n    Raises:\n        ValueError: If the input is not a string.\n\n    Example:\n        >>> find_longest_word(\"The quick brown fox jumps over the lazy dog\")\n        'jumps'\n        >>> find_longest_word(\"Python programming is fun\")\n        'programming'\n    \"\"\"\n    import logging\n    import re\n\n    if not isinstance(text, str):\n        raise ValueError(\"Input must be a string.\")\n\n    # Use regex to find words in the text\n    words = re.findall(r'\\b\\w+\\b', text)\n\n    if not words:\n        return \"\"\n\n    # Find the longest word\n    longest_word = max(words, key=len)\n\n    # Log the longest word found\n    logging.debug(f\"Text: '{text}', Longest word: '{longest_word}'\")\n\n    return longest_word\n",
  "count_sentences": "def count_sentences(text: str) -> int:\n    \"\"\"\n    Count the number of sentences in a given string.\n\n    This function analyzes the input string and counts the number of sentences based on the presence\n    of sentence-ending punctuation marks such as '.', '!', and '?'.\n\n    Args:\n        text (str): The input string to analyze.\n\n    Returns:\n        int: The number of sentences in the input string.\n\n    Raises:\n        ValueError: If the input is not a string.\n\n    Example:\n        >>> count_sentences(\"Hello world! How are you? I'm fine.\")\n        3\n        >>> count_sentences(\"This is a single sentence.\")\n        1\n    \"\"\"\n    import logging\n    import re\n\n    if not isinstance(text, str):\n        raise ValueError(\"Input must be a string.\")\n\n    # Use regex to find sentence-ending punctuation\n    sentences = re.split(r'[.!?]+', text)\n\n    # Filter out any empty strings resulting from split\n    sentence_count = len([s for s in sentences if s.strip()])\n\n    # Log the sentence count\n    logging.debug(f\"Text: '{text}', Sentence count: {sentence_count}\")\n\n    return sentence_count\n",
  "convert_to_binary": "def convert_to_binary(number: int) -> str:\n    \"\"\"\n    Convert an integer to its binary representation.\n\n    This function takes an integer and converts it to a binary string prefixed with '0b'.\n    It handles both positive and negative integers.\n\n    Args:\n        number (int): The integer to convert to binary.\n\n    Returns:\n        str: The binary representation of the integer.\n\n    Raises:\n        ValueError: If the input is not an integer.\n\n    Example:\n        >>> convert_to_binary(10)\n        '0b1010'\n        >>> convert_to_binary(-5)\n        '-0b101'\n    \"\"\"\n    import logging\n\n    if not isinstance(number, int):\n        raise ValueError(\"Input must be an integer.\")\n\n    binary_representation = bin(number)\n\n    logging.debug(f\"Converted integer {number} to binary: {binary_representation}\")\n\n    return binary_representation\n",
  "jump_search": "def jump_search(sorted_list: list[int], target: int) -> int:\n    \"\"\"\n    Perform a jump search on a sorted list to find the index of a target value.\n\n    Jump search is an algorithm that searches for a target value in a sorted list by jumping ahead\n    by a fixed number of steps (block size) and then performing a linear search within the block.\n\n    Args:\n        sorted_list (list[int]): A list of integers sorted in ascending order.\n        target (int): The integer value to search for in the list.\n\n    Returns:\n        int: The index of the target value in the list if found, otherwise -1.\n\n    Raises:\n        ValueError: If the input list is not sorted or if the inputs are not of the correct type.\n\n    Example:\n        >>> jump_search([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 7)\n        6\n        >>> jump_search([10, 20, 30, 40, 50], 25)\n        -1\n    \"\"\"\n    import math\n    import logging\n\n    if not isinstance(sorted_list, list):\n        sorted_list = [sorted_list]\n    if not all(isinstance(x, int) for x in sorted_list):\n        raise ValueError(\"The sorted_list must be a list of integers.\")\n    if not isinstance(target, int):\n        raise ValueError(\"The target must be an integer.\")\n    if sorted_list != sorted(sorted_list):\n        raise ValueError(\"The list must be sorted in ascending order.\")\n\n    n = len(sorted_list)\n    step = int(math.sqrt(n))\n    prev = 0\n\n    logging.debug(f\"Starting jump search for target {target} in list: {sorted_list}\")\n\n    while prev < n and sorted_list[min(step, n) - 1] < target:\n        logging.debug(f\"Jumping from index {prev} to {min(step, n) - 1}\")\n        prev = step\n        step += int(math.sqrt(n))\n        if prev >= n:\n            logging.debug(f\"Target {target} not found in the list\")\n            return -1\n\n    logging.debug(f\"Performing linear search in block starting at index {prev}\")\n\n    for idx in range(prev, min(step, n)):\n        logging.debug(f\"Checking index {idx}: value {sorted_list[idx]}\")\n        if sorted_list[idx] == target:\n            logging.debug(f\"Target {target} found at index {idx}\")\n            return idx\n\n    logging.debug(f\"Target {target} not found in the list\")\n    return -1\n",
  "insertion_sort": "def insertion_sort(arr: list[int]) -> list[int]:\n    \"\"\"\n    Sort a list of integers using the insertion sort algorithm.\n\n    Insertion sort is a simple sorting algorithm that builds the final sorted array one item at a time.\n    It is much less efficient on large lists than more advanced algorithms such as quicksort, heapsort, or merge sort.\n\n    Args:\n        arr (list[int]): A list of integers to be sorted.\n\n    Returns:\n        list[int]: A new list containing the sorted integers.\n\n    Raises:\n        ValueError: If the input is not a list of integers.\n\n    Example:\n        >>> insertion_sort([3, 6, 8, 10, 1, 2, 1])\n        [1, 1, 2, 3, 6, 8, 10]\n        >>> insertion_sort([5, 3, 8, 4, 2])\n        [2, 3, 4, 5, 8]\n    \"\"\"\n    import logging\n\n    if isinstance(arr, int):\n        arr = [arr]\n    elif not isinstance(arr, list):\n        raise ValueError(\"Input must be a list of integers.\")\n    if not all(isinstance(x, int) for x in arr):\n        raise ValueError(\"All elements in the list must be integers.\")\n\n    logging.debug(f\"Initial array: {arr}\")\n\n    for i in range(1, len(arr)):\n        key = arr[i]\n        j = i - 1\n        while j >= 0 and key < arr[j]:\n            arr[j + 1] = arr[j]\n            j -= 1\n        arr[j + 1] = key\n        logging.debug(f\"Array after inserting element {key}: {arr}\")\n\n    logging.debug(f\"Sorted array: {arr}\")\n\n    return arr\n",
  "create_frequency_dict": "def create_frequency_dict(elements: list) -> dict:\n    \"\"\"\n    Create a frequency dictionary from a list of elements.\n\n    This function takes a list of elements and returns a dictionary where the keys are the unique elements\n    from the list and the values are the counts of how many times each element appears in the list.\n\n    Args:\n        elements (list): A list of elements to analyze.\n\n    Returns:\n        dict: A dictionary with elements as keys and their frequency counts as values.\n\n    Raises:\n        ValueError: If the input is not a list.\n\n    Example:\n        >>> create_frequency_dict([1, 2, 2, 3, 3, 3, 4])\n        {1: 1, 2: 2, 3: 3, 4: 1}\n        >>> create_frequency_dict(['apple', 'banana', 'apple', 'cherry'])\n        {'apple': 2, 'banana': 1, 'cherry': 1}\n    \"\"\"\n    import logging\n    from collections import defaultdict\n\n    if not isinstance(elements, list):\n        raise ValueError(\"Input must be a list.\")\n\n    frequency_dict = defaultdict(int)\n\n    for element in elements:\n        frequency_dict[element] += 1\n\n    result = dict(frequency_dict)\n\n    logging.debug(f\"Elements: {elements}, Frequency dictionary: {result}\")\n\n    return result\n",
  "debug_dict_structure": "def debug_dict_structure(data: dict) -> dict[str, any]:\n    \"\"\"\n    Analyze the structure of a dictionary, providing details about its keys and values, including types and nested levels.\n\n    This function inspects a dictionary and returns a dictionary containing information about the types of keys and values,\n    the depth of nesting, and the count of each type of key and value.\n\n    Args:\n        data (dict): The dictionary to analyze.\n\n    Returns:\n        dict[str, any]: A dictionary with keys 'key_types', 'value_types', 'max_depth', 'key_type_counts', and 'value_type_counts'\n                        providing details about the dictionary structure.\n\n    Raises:\n        ValueError: If the input is not a dictionary.\n\n    Example:\n        >>> debug_dict_structure({'a': 1, 'b': \"text\", 'c': {'d': 2}})\n        {'key_types': ['str'], 'value_types': ['int', 'str', 'dict'], 'max_depth': 2, 'key_type_counts': {'str': 3}, 'value_type_counts': {'int': 2, 'str': 1, 'dict': 1}}\n    \"\"\"\n    import logging\n    from collections import defaultdict\n\n    if not isinstance(data, dict):\n        raise ValueError(\"Input must be a dictionary.\")\n\n    def analyze_structure(d: dict, depth: int = 0) -> tuple[set, set, int, defaultdict, defaultdict]:\n        key_types = set()\n        value_types = set()\n        max_depth = depth\n        key_type_counts = defaultdict(int)\n        value_type_counts = defaultdict(int)\n\n        for key, value in d.items():\n            key_type = type(key).__name__\n            value_type = type(value).__name__\n            key_types.add(key_type)\n            value_types.add(value_type)\n            key_type_counts[key_type] += 1\n            value_type_counts[value_type] += 1\n\n            if isinstance(value, dict):\n                sub_key_types, sub_value_types, sub_depth, sub_key_counts, sub_value_counts = analyze_structure(value, depth + 1)\n                key_types.update(sub_key_types)\n                value_types.update(sub_value_types)\n                max_depth = max(max_depth, sub_depth)\n                for k, v in sub_key_counts.items():\n                    key_type_counts[k] += v\n                for k, v in sub_value_counts.items():\n                    value_type_counts[k] += v\n\n        return key_types, value_types, max_depth, key_type_counts, value_type_counts\n\n    key_types, value_types, max_depth, key_type_counts, value_type_counts = analyze_structure(data)\n\n    result = {\n        'key_types': list(key_types),\n        'value_types': list(value_types),\n        'max_depth': max_depth,\n        'key_type_counts': dict(key_type_counts),\n        'value_type_counts': dict(value_type_counts)\n    }\n\n    logging.debug(f\"dictionary structure analysis: {result}\")\n\n    return result\n",
  "sentiment_analysis": "def sentiment_analysis(text: str) -> str:\n    \"\"\"\n    Analyze the sentiment of a given text and determine if it is positive, negative, or neutral.\n\n    Args:\n        text (str): The input string containing the text to analyze for sentiment.\n\n    Returns:\n        str: The sentiment classification of the text, which can be 'positive', 'negative', or 'neutral'.\n\n    Raises:\n        ValueError: If the input is not a string.\n    \"\"\"\n    if not isinstance(text, str):\n        raise ValueError(\"Input must be a string.\")\n\n    # Step 2: Preprocess the text\n    text = text.lower()\n    text = remove_punctuation(text)\n    \n    # Step 3: Tokenize the text\n    tokens = text.split()\n\n    # Step 4: Assign sentiment scores\n    sentiment_score = 0\n    for token in tokens:\n        # Example sentiment lexicon (simplified)\n        if token in ['good', 'happy', 'joyful']:\n            sentiment_score += 1\n        elif token in ['bad', 'sad', 'terrible']:\n            sentiment_score -= 1\n\n    # Step 5: Aggregate sentiment scores\n    if sentiment_score > 0:\n        return 'positive'\n    elif sentiment_score < 0:\n        return 'negative'\n    else:\n        return 'neutral'\n"
}